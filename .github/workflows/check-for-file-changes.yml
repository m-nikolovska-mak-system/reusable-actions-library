name: Check File Changes

on:
  workflow_call:
    inputs:
      watched_files:
        description: 'Files to watch (comma-separated or newline-separated)'
        required: true
        type: string
      current_tag:
        description: 'Current release tag (defaults to github.event.release.tag_name)'
        required: false
        type: string
        default: ''
      previous_tag:
        description: 'Previous tag to compare against (auto-detected if empty)'
        required: false
        type: string
        default: ''
    outputs:
      files_changed:
        description: 'true if any watched files changed'
        value: ${{ jobs.check-changes.outputs.files_changed }}
      changed_files_list:
        description: 'Comma-separated list of changed files'
        value: ${{ jobs.check-changes.outputs.changed_files_list }}

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      files_changed: ${{ steps.check.outputs.files_changed }}
      changed_files_list: ${{ steps.check.outputs.changed_files_list }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to compare tags

      - name: Determine tags to compare
        id: tags
        run: |
          set -e  # Exit on any error
          
          # Get current tag from input or event
          current_tag="${{ inputs.current_tag }}"
          if [ -z "$current_tag" ]; then
            current_tag="${{ github.event.release.tag_name }}"
          fi
          
          if [ -z "$current_tag" ]; then
            echo "❌ ERROR: No current tag provided and no release event found"
            echo "Please provide current_tag input or trigger from a release event"
            exit 1
          fi
          
          echo "current_tag=$current_tag" >> $GITHUB_OUTPUT
          echo "Current tag: $current_tag"
          
          # Verify current tag exists
          if ! git rev-parse "$current_tag" >/dev/null 2>&1; then
            echo "❌ ERROR: Tag '$current_tag' does not exist in repository"
            exit 1
          fi
          
          # Get previous tag
          prev_tag="${{ inputs.previous_tag }}"
          
          if [ -z "$prev_tag" ]; then
            echo "Auto-detecting previous tag..."
            git fetch --tags --force
            
            # Get all tags sorted by creation date, exclude current tag
            prev_tag=$(git tag --sort=-creatordate | grep -v "^${current_tag}$" | head -n1)
            
            if [ -z "$prev_tag" ]; then
              echo "⚠️ No previous tag found. This appears to be the first release."
              echo "Using first commit as base for comparison."
              prev_tag=$(git rev-list --max-parents=0 HEAD)
            fi
          else
            # Verify provided previous tag exists
            if ! git rev-parse "$prev_tag" >/dev/null 2>&1; then
              echo "❌ ERROR: Provided previous tag '$prev_tag' does not exist"
              exit 1
            fi
          fi
          
          echo "prev_tag=$prev_tag" >> $GITHUB_OUTPUT
          echo "Previous tag: $prev_tag"
          
          # Validate that we can actually diff these refs
          if ! git diff --name-only "$prev_tag" "$current_tag" >/dev/null 2>&1; then
            echo "❌ ERROR: Cannot compare $prev_tag and $current_tag"
            exit 1
          fi

      - name: Check for file changes
        id: check
        run: |
          set -e
          
          base_ref="${{ steps.tags.outputs.prev_tag }}"
          head_ref="${{ steps.tags.outputs.current_tag }}"
          
          echo "=========================================="
          echo "Checking file changes"
          echo "From: $base_ref"
          echo "To:   $head_ref"
          echo "=========================================="
          
          # Get changed files
          if ! changed_files=$(git diff --name-only "$base_ref" "$head_ref" 2>&1); then
            echo "❌ ERROR: Failed to get changed files"
            echo "$changed_files"
            exit 1
          fi
          
          echo "Changed files in release:"
          if [ -z "$changed_files" ]; then
            echo "  (no files changed)"
          else
            echo "$changed_files" | sed 's/^/  /'
          fi
          echo ""
          
          # Parse watched files
          watched_files=$(echo "${{ inputs.watched_files }}" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')
          
          echo "Watching files:"
          echo "$watched_files" | sed 's/^/  /'
          echo ""
          
          # Check each watched file
          files_changed="false"
          changed_files_list=""
          
          while IFS= read -r watched_file; do
            [ -z "$watched_file" ] && continue
            
           match=$(git diff --name-only "$base_ref" "$head_ref" -- "$watched_file")
            
            if [ -n "$match" ]; then
                files_changed="true"
                echo "  ✓ CHANGED (pattern match): $watched_file"
                changed_files_list="${changed_files_list:+$changed_files_list,}$watched_file"
            else
                echo "  ✗ No change: $watched_file"
            fi

          done <<< "$watched_files"
          
          echo ""
          echo "=========================================="
          echo "RESULT: files_changed=$files_changed"
          if [ "$files_changed" = "true" ]; then
            echo "Changed files: $changed_files_list"
          else
            echo "No watched files were changed in this release"
          fi
          echo "=========================================="
          
          # Set outputs
          echo "files_changed=$files_changed" >> $GITHUB_OUTPUT
          echo "changed_files_list=$changed_files_list" >> $GITHUB_OUTPUT
